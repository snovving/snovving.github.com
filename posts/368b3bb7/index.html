<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CVE-2021-40438 Apache mod_proxy SSRF 漏洞分析 | snovving</title><meta name="keywords" content="SSRF,Apache,mod_proxy"><meta name="author" content="snovving"><meta name="copyright" content="snovving"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="安全客投稿的第四篇，年末精神不太好，拖延到 12 月 15 号才完成，以此自省。">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2021-40438 Apache mod_proxy SSRF 漏洞分析">
<meta property="og:url" content="https://snovving.top/posts/368b3bb7/index.html">
<meta property="og:site_name" content="snovving">
<meta property="og:description" content="安全客投稿的第四篇，年末精神不太好，拖延到 12 月 15 号才完成，以此自省。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-11-21T11:30:00.000Z">
<meta property="article:modified_time" content="2021-12-28T13:30:09.444Z">
<meta property="article:author" content="snovving">
<meta property="article:tag" content="SSRF">
<meta property="article:tag" content="Apache">
<meta property="article:tag" content="mod_proxy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/snow.png"><link rel="canonical" href="https://snovving.top/posts/368b3bb7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: snovving","link":"链接: ","source":"来源: snovving","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CVE-2021-40438 Apache mod_proxy SSRF 漏洞分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-28 21:30:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="snovving" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-img-1308029004.cos.ap-shanghai.myqcloud.com/1640695032538.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">snovving</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">CVE-2021-40438 Apache mod_proxy SSRF 漏洞分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-21T11:30:00.000Z" title="发表于 2021-11-21 19:30:00">2021-11-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-28T13:30:09.444Z" title="更新于 2021-12-28 21:30:09">2021-12-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">漏洞复现</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">C代码审计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CVE-2021-40438 Apache mod_proxy SSRF 漏洞分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><blockquote><p>文章首发于安全客。</p>
</blockquote>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>复现这个漏洞的过程中觉得很有分析的必要，而作者源码结合 log 调试分析的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://firzen.de/building-a-poc-for-cve-2021-40438">这篇文章</a>已经写得比较详尽了，就想自己纯从审计的角度写一下分析巩固一下。</p>
<p>总之，如有不当，烦请评论捉虫，我会在第一时间响应并评论提示，谢谢。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><img src="http://blog-img-1308029004.cossh.myqcloud.com/image-20211209084402856.png" alt="image-20211209084402856" style="zoom:80%;" />

<p>可构造 uri 使 mod_proxy 请求转发给内部服务器造成 SSRF 。</p>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><img src="http://blog-img-1308029004.cossh.myqcloud.com/image-20211121200332290.png" alt="image-20211121200332290" style="zoom: 80%;" />

<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>代审环节个人建议是亲手编译调试 Apache 跟进，可以参照 P 神的教程：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://wx.zsxq.com/dweb2/index/topic_detail/418885442584848">编译调试 Apache</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://wx.zsxq.com/dweb2/index/topic_detail/218882521544551">调试补充事项</a></p>
<p>不一定要 Ubantu，Kali 上笔者也调试成功了，最好用 VS，另外如果你想尝试用 CLion，可以参照下面的链接进行 SSH 远程调试，其余步骤都同上一样：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.jetbrains.com/clion/2018/09/initial-remote-dev-support-clion/">Stay local, let your IDE do remote work for you! | The CLion Blog (jetbrains.com)</a></p>
<p>CLion 调试需要注意有 cmake 和 gdb 版本限制，最好不要下载最新版本避免还要用软链接重新下载某一指定版本，或者更新 CLion 也是可以的。</p>
<h2 id="前置学习"><a href="#前置学习" class="headerlink" title="前置学习"></a>前置学习</h2><p>为了理解漏洞原理，笔者个人认为是需要 Apache 和 PHP 一些前置知识学习的，就简单概括了并使之递进加深理解，很多点都会在分析过程中用到，行文结合了许多官方文档和自身理解整理以确保准确，如有缺漏不当之处，还请指出。</p>
<h3 id="Apache-部署-php"><a href="#Apache-部署-php" class="headerlink" title="Apache 部署 php"></a>Apache 部署 php</h3><p>众所周知，php 有五种运行模式，其中最常见的三种 CGI、FastCGI、Module 加载或者说 apache2handler 更为恰当（linux 下）。</p>
<p>Module 加载这种模式一般对于 Apache 而言，简单来说，就是把 PHP 作为 Apache 的一个子模块来运行，用 LoadModule 加载模块，最主要的模块就是 mod_php，漏洞实验环境配置调试也是以 LoadModule 加载 mod_proxy 的。</p>
<p>而 FastCGI 这个模式下会用到 PHP-FPM 这个进程管理器进行 FastCGI 管理，而非 CGI 的用 Web 服务器管理，其中的子进程叫做 PHP-CGI ，<strong>这次漏洞的突破点 mod_proxy 就与 PHP-FPM 有关，它从 PHP 5.3.3 就成为了 PHP 的内置管理器，所以配合这个从 Apache httpd 2.4.x 推出了使用 mod_proxy 的子模块 mod_proxy_fcgi 和 PHP-FPM 部署更高性能的 PHP 运行环境。</strong></p>
<p>虽然现在明显用 Nginx+PHP-FPM 是更好的选择 :-)</p>
<h3 id="mod-proxy-反向代理"><a href="#mod-proxy-反向代理" class="headerlink" title="mod_proxy 反向代理"></a>mod_proxy 反向代理</h3><p>顾名思义，这个模块与其相关模块为 Apache HTTP Server 实现代理 / 网关。</p>
<p>前面有说到 High-performance PHP on apache httpd 2.4.x using mod_proxy_fcgi and php-fpm 这种方式，本质就是 Apache 作为反代服务器用 mod_proxy_fcgi 这个子模块请求转发给 PHP-FPM ，而 PHP-FPM 监听的方式，也就是接收 Apache 转过去时处理 PHP 的请求的方式，有两种：</p>
<ol>
<li><p>TCP Socket（ip and port）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyPass / http://www.example.com:port</span><br></pre></td></tr></table></figure></li>
<li><p>UDS （Unix Domain Socket） </p>
<p><strong>只在Apache 2.4.7 及更高版本中支持。</strong></p>
<p>可以通过使用位于 <code>unix:/path/app.sock|</code> 前面的目标来支持使用 UDS 。例如，要代理 HTTP 并将 UDS 定位于 /home/<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.socket/">www.socket</a> ，应使用 <code>unix:/home/www.socket|http://localhost/whatever/</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyPass / unix:/path/to/app.sock|http://example.com/app/name</span><br></pre></td></tr></table></figure></li>
</ol>
<p>对于反向代理而言， Apache 转发代理，也就是 Apache 发送请求给 PHP-FPM 的方式有三种，其中一种叫 ProxyPass ，这是指令，允许将远程服务器 Map 到本地服务器（反向代理 / 网关）的空间，对于不同监听方式的指令例子如上所示。</p>
<h3 id="Apache-hook-机制"><a href="#Apache-hook-机制" class="headerlink" title="Apache hook 机制"></a>Apache hook 机制</h3><p>说起 Apache Module 不能不提起 Apache hook，想要处理请求，要做的第一件事就是在请求处理过程中创建一个 hook，所有处理程序，就比如我们上面说到的 mod_proxy ，都会被挂接到请求过程的特定部分。服务器本身是不知道哪个模块负责处理特定请求的，所以会询问每个模块是否对给定请求感兴趣。然后，由每个模块决定是否像身份验证 / 授权模块那样拒绝服务请求，接受服务请求或拒绝服务请求，就像下图一样。</p>
<img src="http://blog-img-1308029004.cossh.myqcloud.com/image-20211214095139626.png" alt="image-20211214095139626" style="zoom:80%;" />

<p>为了使诸如 mod_example 之类的处理程序更容易知道 Client 端是否在请求我们应处理的内容，服务器具有用于向模块提示是否需要其协助的指令。其中两个是 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.docs4dev.com/docs/zh/apache/2.4/reference/mod-mod_mime.html#addhandler">AddHandler</a> 和 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.docs4dev.com/docs/zh/apache/2.4/reference/mod-core.html#sethandler">SetHandler</a>。</p>
<p>为此可以看一个例子理解，比如我们想通过创建合适的 Handler 传递，将请求强制处理为反向代理请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;\.php$&quot;&gt;</span><br><span class="line">    # Unix sockets require 2.4.7 or later</span><br><span class="line">    SetHandler  &quot;proxy:unix:/path/to/app.sock|fcgi://localhost/&quot;</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>这个例子是使用反向代理将对 PHP 脚本的所有请求传递到指定的 FastCGI 服务器，是不是和之前 UDS 的例子很像？</p>
<p>一个 Module 通常是在 Handler 中创建一个 hook，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register_hooks</span><span class="params">(<span class="keyword">apr_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Create a hook in the request handler, so we get called when a request arrives */</span></span><br><span class="line">    ap_hook_handler(example_handler, <span class="literal">NULL</span>, <span class="literal">NULL</span>, APR_HOOK_LAST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，继而就会在 example_handler 这个函数中处理请求，mod_proxy 也有这样的 Handler 。</p>
<p>另外还要提到的就是 request_rec 结构。</p>
<p>任何请求中最重要的部分是 request record 。在对处理程序函数的调用中，这由与进行的每次调用一起传递的 <code>request_rec*</code> 结构表示。该结构在模块中通常简称为 <code>r</code> ，包含模块完全处理任何 HTTP 请求并相应做出响应所需的所有信息。</p>
<img src="http://blog-img-1308029004.cossh.myqcloud.com/image-20211214102827262.png" alt="image-20211214102827262" style="zoom:80%;" />

<p>其中这个 <code>r-&gt;filename</code> 还有其他几个我们就会在分析过程中接触到。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>以 Apache 2.4.48 源代码审计，<strong>不同版本会有些出入</strong>。</p>
<p><strong>注意审计这部分着重看代码中的注释，笔者所写的有很大一部分解释和分析都在其中，修复的部分会标 * ，一定要看注释配合理解！</strong></p>
<p>[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://svn.apache.org/viewvc?view=revision&revision=1892814">Apache-SVN] Revision 1892814</a></p>
<p>直接来看修复前后的对比分析缺陷在哪，还有漏洞本质上是什么问题。</p>
<p>官方的函数解释看这个文档：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__DAEMON.html#gaa6a7169f7d3801b11d3b113b27284dbd">Apache2: HTTP Daemon Routine</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">--- httpd/httpd/trunk/modules/proxy/proxy_util.c    <span class="number">2021</span>/<span class="number">09</span>/<span class="number">02</span> <span class="number">12</span>:<span class="number">33</span>:<span class="number">49</span> <span class="number">1892813</span></span><br><span class="line">+++ httpd/httpd/trunk/modules/proxy/proxy_util.c    <span class="number">2021</span>/<span class="number">09</span>/<span class="number">02</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">02</span> <span class="number">1892814</span></span><br><span class="line">@@ <span class="number">-2274</span>,<span class="number">8</span> +<span class="number">2274</span>,<span class="number">8</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fix_uds_filename</span><span class="params">(request_rec *r, <span class="keyword">char</span> **url)</span></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> *ptr, *ptr2;</span><br><span class="line">     <span class="keyword">if</span> (!r || !r-&gt;filename) <span class="keyword">return</span>;</span><br><span class="line">  	 </span><br><span class="line">     <span class="comment">// COND1：r-&gt;filename 前 6 个字符必须是 proxy:</span></span><br><span class="line">     <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(r-&gt;filename, <span class="string">&quot;proxy:&quot;</span>, <span class="number">6</span>) &amp;&amp;</span><br><span class="line">             <span class="comment">// COND2：r-&gt;filename 必须有 unix: 这个字符串，但不区分大小写，这不同于 strstr</span></span><br><span class="line">-            (ptr2 = ap_strcasestr(r-&gt;filename, <span class="string">&quot;unix:&quot;</span>)) &amp;&amp;</span><br><span class="line">             <span class="comment">// COND3：COND2 对 r-&gt;filename 进行了截取，这条是判断 unix: 这个字符串后的部分是否有 | </span></span><br><span class="line">-            (ptr = ap_strchr(ptr2, <span class="string">&#x27;|&#x27;</span>))) &#123;</span><br><span class="line">         	 <span class="comment">// *COND2：不区分大小写对两个字符串进行比较，也就是这里 r-&gt;filename 必须以 proxy:unix: 开头</span></span><br><span class="line">+            !ap_cstr_casecmpn(r-&gt;filename + <span class="number">6</span>, <span class="string">&quot;unix:&quot;</span>, <span class="number">5</span>) &amp;&amp;</span><br><span class="line">    		 <span class="comment">// *COND3：ptr2 指 proxy:unix: 后的部分，这里判断字符串中那个是否有 | ，与 COND3 要求一致</span></span><br><span class="line">+            (ptr2 = r-&gt;filename + <span class="number">6</span> + <span class="number">5</span>, ptr = ap_strchr(ptr2, <span class="string">&#x27;|&#x27;</span>))) &#123;</span><br><span class="line">    </span><br><span class="line">         <span class="keyword">apr_uri_t</span> urisock;</span><br><span class="line">         <span class="keyword">apr_status_t</span> rv;</span><br><span class="line">         *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    	 <span class="comment">// 举例：ProxyPass / unix:/path/to/app.sock|http://example.com/app/name 我们来看这些参数的值</span></span><br><span class="line">         <span class="comment">// 这里解析给定的 uri ，填写 apr_uri_t 结构的一些字段，避免重复提取主机端口、路径这些</span></span><br><span class="line">         rv = apr_uri_parse(r-&gt;pool, ptr2, &amp;urisock);</span><br><span class="line">    	 <span class="comment">// 如果解析成功（apr_uri_parse Returns APR_SUCCESS for success or error code）</span></span><br><span class="line">         <span class="keyword">if</span> (rv == APR_SUCCESS) &#123;</span><br><span class="line">             <span class="comment">// 这里 rurl 即 redirect url 在例子中就是 http://example.com/app/name，需要重定向到的地址</span></span><br><span class="line">             <span class="keyword">char</span> *rurl = ptr+<span class="number">1</span>;</span><br><span class="line">             <span class="comment">// 返回相对路径，在例子中 uds_path 就是 /path/to/app.sock</span></span><br><span class="line">             <span class="keyword">char</span> *sockpath = ap_runtime_dir_relative(r-&gt;pool, urisock.path);</span><br><span class="line">             <span class="comment">// 将 uds_path 键值对添加到 r-&gt;notes</span></span><br><span class="line">             apr_table_setn(r-&gt;notes, <span class="string">&quot;uds_path&quot;</span>, sockpath);</span><br><span class="line">             *url = apr_pstrdup(r-&gt;pool, rurl); <span class="comment">/* so we get the scheme for the uds */</span></span><br><span class="line">             <span class="comment">/* r-&gt;filename starts w/ &quot;proxy:&quot;, so add after that */</span></span><br><span class="line">             memmove(r-&gt;filename+<span class="number">6</span>, rurl, <span class="built_in">strlen</span>(rurl)+<span class="number">1</span>);</span><br><span class="line">             <span class="comment">// 记录信息</span></span><br><span class="line">             ap_log_rerror(APLOG_MARK, APLOG_TRACE2, <span class="number">0</span>, r,</span><br><span class="line">                     <span class="string">&quot;*: rewrite of url due to UDS(%s): %s (%s)&quot;</span>,</span><br><span class="line">                     sockpath, *url, r-&gt;filename);</span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             *ptr = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合注解，可以看出 <code>fix_uds_filename</code> 这个函数本身就是用于解析并填写 uri ，文件名标识 UDS ，然后通过管道符 <code>|</code> 后面的内容重定向到它。</p>
<p>对比 COND2 和 *COND2 ，我们知道这个漏洞的修复就是单纯强制要求 <code>proxy:unix:</code> 开头，COND2 我们也能看出只要是有 <code>unix:</code> 字样而且不论大小写都能被解析，显然是判定宽松出了问题，为了更好理解我们先来看 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/_mattata/status/1449020783989297167">remy🐀 在 Twitter: “CVE-2021-40438 Apache SSRF as a one-liner./ Twitter</a> 上的一个 poc ：</p>
<img src="http://blog-img-1308029004.cossh.myqcloud.com/image-20211214033514714.png" alt="image-20211214033514714" style="zoom: 67%;" />

<p>可以看到 <code>unix:</code> 后它拼接了共 7701 个字符的 A ，可以猜想这其中一定有缓冲区或者错误处理的问题，来看修复前拼接的效果，假设我们发送的请求如下，显然是让代理一个 http 请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/?unix:$(python3 -c &#x27;print(&quot;A&quot;*7701, end=&quot;&quot;)&#x27;)|http://backend_server1:8085/</span><br></pre></td></tr></table></figure>

<p>代理请求拼接后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy:http://localhost/?unix:$(python3 -c &#x27;print(&quot;A&quot;*7701, end=&quot;&quot;)&#x27;)|http://backend_server1:8085/</span><br></pre></td></tr></table></figure>

<p>这里就又因为包含 <code>unix:</code> ，满足 COND2 ，<strong>就从 http 请求变成了有效的 UDS 代理重定向请求。</strong></p>
<p>解释到这，我们明白问题本质后，先来分析什么是我们可控的，再来从 UDS 解析过程上分析为什么要拼接将近 7000 个字符才能攻击成功。</p>
<h4 id="哪部分是可控的？"><a href="#哪部分是可控的？" class="headerlink" title="哪部分是可控的？"></a>哪部分是可控的？</h4><p>之前在前置知识学习中，笔者有提到过 mod_proxy 有它处理请求的 Handler，我们从这个函数来看哪些是我们可控的，当然，认真看了上部分内容的你，一定知道 <code>r-&gt;filename</code> 是关键。</p>
<p>modules/proxy/mod_proxy_http.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ap_proxy_http_register_hook</span><span class="params">(<span class="keyword">apr_pool_t</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ap_hook_post_config(proxy_http_post_config, <span class="literal">NULL</span>, <span class="literal">NULL</span>, APR_HOOK_MIDDLE);</span><br><span class="line">    proxy_hook_scheme_handler(proxy_http_handler, <span class="literal">NULL</span>, <span class="literal">NULL</span>, APR_HOOK_FIRST);</span><br><span class="line">    proxy_hook_canon_handler(proxy_http_canon, <span class="literal">NULL</span>, <span class="literal">NULL</span>, APR_HOOK_FIRST);</span><br><span class="line">    warn_rx = ap_pregcomp(p, <span class="string">&quot;[0-9]&#123;3&#125;[ \t]+[^ \t]+[ \t]+\&quot;[^\&quot;]*\&quot;([ \t]+\&quot;([^\&quot;]+)\&quot;)?&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到有两个 hook，我们来看 <code>proxy_http_canon</code> 这个 Handler，是用于处理反代请求的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">proxy_http_canon</span><span class="params">(request_rec *r, <span class="keyword">char</span> *url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get_url_scheme 是检查该请求是否是（h / H 开头） 再判断是否是 http / https，也就是该不该由 mod_proxy_http 处理</span></span><br><span class="line">    <span class="comment">// schema pass</span></span><br><span class="line">    scheme = get_url_scheme((<span class="keyword">const</span> <span class="keyword">char</span> **)&amp;url, &amp;is_ssl);</span><br><span class="line">    <span class="keyword">if</span> (!scheme) &#123;</span><br><span class="line">        <span class="keyword">return</span> DECLINED;</span><br><span class="line">    &#125;</span><br><span class="line">    port = def_port = (is_ssl) ? DEFAULT_HTTPS_PORT : DEFAULT_HTTP_PORT;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (r-&gt;proxyreq) &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* wtf are we doing here? */</span></span><br><span class="line">    <span class="keyword">case</span> PROXYREQ_REVERSE:</span><br><span class="line">        <span class="keyword">if</span> (apr_table_get(r-&gt;notes, <span class="string">&quot;proxy-nocanon&quot;</span>)) &#123;</span><br><span class="line">            path = url;   <span class="comment">/* this is the raw path */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            path = ap_proxy_canonenc(r-&gt;pool, url, <span class="built_in">strlen</span>(url),</span><br><span class="line">                                     enc_path, <span class="number">0</span>, r-&gt;proxyreq);</span><br><span class="line">            search = r-&gt;args;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PROXYREQ_PROXY:</span><br><span class="line">        path = url;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> HTTP_BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port != def_port)</span><br><span class="line">        apr_snprintf(sport, <span class="keyword">sizeof</span>(sport), <span class="string">&quot;:%d&quot;</span>, port);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sport[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// host pass</span></span><br><span class="line">    <span class="keyword">if</span> (ap_strchr_c(host, <span class="string">&#x27;:&#x27;</span>)) &#123; <span class="comment">/* if literal IPv6 address */</span></span><br><span class="line">        host = apr_pstrcat(r-&gt;pool, <span class="string">&quot;[&quot;</span>, host, <span class="string">&quot;]&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终拼接赋值给 r-&gt;filename</span></span><br><span class="line">    r-&gt;filename = apr_pstrcat(r-&gt;pool, <span class="string">&quot;proxy:&quot;</span>, scheme, <span class="string">&quot;://&quot;</span>, host, sport,</span><br><span class="line">                              <span class="string">&quot;/&quot;</span>, path, (search) ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&quot;</span>, search, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合注释，可以看到最终只有 <code>path</code> 和 <code>search</code> 是我们可控的，<code>r-&gt;filename</code> 后半部分可控也恰恰是 <code>|</code> 后的后端地址。</p>
<h4 id="UDS-解析过程"><a href="#UDS-解析过程" class="headerlink" title="UDS 解析过程"></a>UDS 解析过程</h4><p>之前在代码注释中也提到过，<code>uds_path</code> 就是 <code>unix:</code> 与 <code>|</code> 之间的部分，在 poc 中就是那近 7000 的字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *sockpath = ap_runtime_dir_relative(r-&gt;pool, urisock.path);</span><br><span class="line"><span class="comment">// 将 uds_path 键值对添加到 r-&gt;notes</span></span><br><span class="line">apr_table_setn(r-&gt;notes, <span class="string">&quot;uds_path&quot;</span>, sockpath);</span><br></pre></td></tr></table></figure>

<p>先来看 <code>ap_runtime_dir_relative</code> 做了什么。</p>
<p>server/config.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ap_runtime_dir_relative(r-&gt;pool, urisock.path)</span></span><br><span class="line">AP_DECLARE(<span class="keyword">char</span> *) ap_runtime_dir_relative(<span class="keyword">apr_pool_t</span> *p, <span class="keyword">const</span> <span class="keyword">char</span> *file)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *newpath = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">apr_status_t</span> rv;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *runtime_dir = ap_runtime_dir ? ap_runtime_dir : ap_server_root_relative(p, DEFAULT_REL_RUNTIMEDIR);</span><br><span class="line"></span><br><span class="line">    rv = apr_filepath_merge(&amp;newpath, runtime_dir, file,</span><br><span class="line">                            APR_FILEPATH_TRUENAME, p);</span><br><span class="line">    <span class="keyword">if</span> (newpath &amp;&amp; (rv == APR_SUCCESS || APR_STATUS_IS_EPATHWILD(rv)</span><br><span class="line">                                      || APR_STATUS_IS_ENOENT(rv)</span><br><span class="line">                                      || APR_STATUS_IS_ENOTDIR(rv))) &#123;</span><br><span class="line">        <span class="keyword">return</span> newpath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到调用了 apr 库的 <code>apr_filepath_merge</code> 这个函数。</p>
<p>apr/file_io/unix/filepath.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apr_filepath_merge(&amp;newpath, runtime_dir, file,APR_FILEPATH_TRUENAME, p)</span></span><br><span class="line">APR_DECLARE(<span class="keyword">apr_status_t</span>) apr_filepath_merge(<span class="keyword">char</span> **newpath,</span><br><span class="line">                                             <span class="keyword">const</span> <span class="keyword">char</span> *rootpath,</span><br><span class="line">                                             <span class="keyword">const</span> <span class="keyword">char</span> *addpath,</span><br><span class="line">                                             <span class="keyword">apr_int32_t</span> flags,</span><br><span class="line">                                             <span class="keyword">apr_pool_t</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rootlen = <span class="built_in">strlen</span>(rootpath);</span><br><span class="line">    maxlen = rootlen + <span class="built_in">strlen</span>(addpath) + <span class="number">4</span>; <span class="comment">/* 4 for slashes at start, after</span></span><br><span class="line"><span class="comment">                                             * root, and at end, plus trailing</span></span><br><span class="line"><span class="comment">                                             * null */</span></span><br><span class="line">    <span class="keyword">if</span> (maxlen &gt; APR_PATH_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> APR_ENAMETOOLONG;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>apr_filepath_merge</code> 这个函数简单描述就是将 <code>addpath</code> 合并到预先处理的 <code>rootpath</code> 上，在这里就是 <code>file</code> 合并到 <code>runtime_dir</code> 。</p>
<p>对省略的部分解释一下，这里的 <code>flags</code> 因为是 <code>APR_FILEPATH_TRUENAME</code>（这是合并的规则），流程大概就是检查 <code>file</code> 这个 <code>addpath</code> 是否包含一些平台不支持的通配符（ <code>*</code> 、<code>?</code>），其他情况是处理绝对 / 相对路径的一些规则。</p>
<p>可以看到我们截取出来的部分，如果 <code>maxlen</code> 也就是 <code>rootpath</code> 和 <code>addpath</code> 长度 + 4 如果大于 <code>APR_PATH_MAX</code>（ linux 与 win 不同，是4096），就会返回一个 <code>APR_ENAMETOOLONG</code> 的错误，这个错误赋值给 <code>rv</code> ，在 <code>ap_runtime_dir_relative</code> 中是最后会进入 else 分支 <strong>return NULL</strong> 的。</p>
<p>之后在 modules/proxy/proxy_util.c 中 <code>ap_proxy_determine_connection</code> 确定后端主机名和端口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">PROXY_DECLARE(<span class="keyword">int</span>)</span><br><span class="line">ap_proxy_determine_connection(<span class="keyword">apr_pool_t</span> *p, request_rec *r,</span><br><span class="line">                              proxy_server_conf *conf,</span><br><span class="line">                              proxy_worker *worker,</span><br><span class="line">                              proxy_conn_rec *conn,</span><br><span class="line">                              <span class="keyword">apr_uri_t</span> *uri,</span><br><span class="line">                              <span class="keyword">char</span> **url,</span><br><span class="line">                              <span class="keyword">const</span> <span class="keyword">char</span> *proxyname,</span><br><span class="line">                              <span class="keyword">apr_port_t</span> proxyport,</span><br><span class="line">                              <span class="keyword">char</span> *server_portstr,</span><br><span class="line">                              <span class="keyword">int</span> server_portstr_size)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 这里是不是很熟悉？</span></span><br><span class="line">    <span class="comment">// 还记得之前有这句 apr_table_setn(r-&gt;notes, &quot;uds_path&quot;, sockpath); 将 uds_path 键值对添加到 r-&gt;notes 吗？</span></span><br><span class="line">    <span class="comment">// 这里就是在检验 uds_path 的值</span></span><br><span class="line">    uds_path = (*worker-&gt;s-&gt;uds_path ? worker-&gt;s-&gt;uds_path : apr_table_get(r-&gt;notes, <span class="string">&quot;uds_path&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (uds_path) &#123;</span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;uds_path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* use (*conn)-&gt;pool instead of worker-&gt;cp-&gt;pool to match lifetime */</span></span><br><span class="line">            conn-&gt;uds_path = apr_pstrdup(conn-&gt;pool, uds_path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;uds_path) &#123;</span><br><span class="line">            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, <span class="number">0</span>, r, APLOGNO(<span class="number">02545</span>)</span><br><span class="line">                         <span class="string">&quot;%s: has determined UDS as %s&quot;</span>,</span><br><span class="line">                         uri-&gt;scheme, conn-&gt;uds_path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* should never happen */</span></span><br><span class="line">            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, <span class="number">0</span>, r, APLOGNO(<span class="number">02546</span>)</span><br><span class="line">                         <span class="string">&quot;%s: cannot determine UDS (%s)&quot;</span>,</span><br><span class="line">                         uri-&gt;scheme, uds_path);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * In UDS cases, some structs are NULL. Protect from de-refs</span></span><br><span class="line"><span class="comment">         * and provide info for logging at the same time.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!conn-&gt;addr) &#123;</span><br><span class="line">            <span class="keyword">apr_sockaddr_t</span> *sa;</span><br><span class="line">            apr_sockaddr_info_get(&amp;sa, <span class="literal">NULL</span>, APR_UNSPEC, <span class="number">0</span>, <span class="number">0</span>, conn-&gt;pool);</span><br><span class="line">            conn-&gt;addr = sa;</span><br><span class="line">        &#125;</span><br><span class="line">        conn-&gt;hostname = <span class="string">&quot;httpd-UDS&quot;</span>;</span><br><span class="line">        conn-&gt;port = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对照注释，如果我们发送超长字符，导致 <code>uds_path</code> 为 <code>NULL</code> 的话，就会进入 else 分支，它们具体处理大致是这样一个情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uds_path) &#123; </span><br><span class="line">    <span class="comment">// Prepare UDS request…</span></span><br><span class="line">    <span class="comment">// 用 UDS 继续通信</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Prepare standard proxy request…</span></span><br><span class="line">    <span class="comment">// 转而用 TCP 通信</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里结合所有内容就可以看出来了，进入 else 分支把请求最终解释成了标准代理请求如 http://<SSRF_TARGET> ，就导致了可以向内部网络任意 Apache 服务器发送请求，请求执行成功，SSRF 触发。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>有时会报 503 的错误，多试几次就行了。</p>
<img src="http://blog-img-1308029004.cossh.myqcloud.com/image-20211215041523606.png" alt="image-20211215041523606" style="zoom:80%;" />

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cwiki.apache.org/confluence/display/HTTPD/PHP-FPM">PHP-FPM - HTTPD - Apache Software Foundation</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/xuey/p/10059050.html">PHP 五大运行模式 - 雪剑无影 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/tssc/p/10255590.html#_label2_0">关于CGI和FastCGI的理解 - 天生帅才 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.fujieace.com/php/modes.html">PHP运行模式有哪几种？ - 付杰博客 (fujieace.com)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/yueyecheshou1980/article/details/106227285/">Apache httpd 使用 mod_proxy_fcgi的方式php-fpm_yueyecheshou1980的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/liuxinyustu/articles/10399883.html">APACHE PHP的几种运行方式（CGI,FASTCGI） - liuxinyu123 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.iteye.com/blog/tcspecial-2070075">Fastcgi FastCgiExternalServer mod_proxy - 云淡风清 - ITeye博客</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://httpd.apache.org/docs/trunk/mod/mod_proxy.html">mod_proxy - Apache HTTP Server Version 2.5</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://ci.apache.org/projects/httpd/trunk/doxygen/group__APACHE__CORE__CONFIG.html#gaff5ad1f7fa1d04009c2697453324e93e">Apache2: Configuration</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.docs4dev.com/docs/zh/apache/2.4/reference/developer-modguide.html">Apache 中文文档 - 为 Apache HTTP Server 2.4 开发模块 | Docs4dev</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://baijiahao.baidu.com/s?id=1659476214623211564&wfr=spider&for=pc">PHP运行方式介绍 (baidu.com)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://firzen.de/building-a-poc-for-cve-2021-40438">Building a POC for CVE-2021-40438 – Firzens Blog</a></p>
<p>[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://koromoon.blogspot.com/2021/12/cve-2021-40438-apache-http-server.html">CVE-2021-40438] Apache HTTP Server mod_proxy SSRF Vulnerability - KOROMOON</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://cydrill.com/owasp/apache-ssrf-an-all-you-can-eat-reverse-proxy/">Apache SSRF: an all-you-can-eat reverse proxy &gt; Cydrill Software Security</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lionic.com/news/2021/12/05/multiple-vulnerabilities-in-recent-apache-web-server/">Multiple Vulnerabilities in recent Apache Web Server | LIONIC-鴻璟科技</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.leavesongs.com/PENETRATION/apache-mod-proxy-ssrf-cve-2021-40438.html#">Apache mod_proxy SSRF（CVE-2021-40438）的一点分析和延伸 | 离别歌 (leavesongs.com)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://47.98.250.156/2021/10/25/CVE-2021-40438/">CVE-2021-40438 | 0pa9ue</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">snovving</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://snovving.top/posts/368b3bb7/">https://snovving.top/posts/368b3bb7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://snovving.top" target="_blank">snovving</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SSRF/">SSRF</a><a class="post-meta__tags" href="/tags/Apache/">Apache</a><a class="post-meta__tags" href="/tags/mod-proxy/">mod_proxy</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-img-1308029004.cos.ap-shanghai.myqcloud.com/1640695032538.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">snovving</div><div class="author-info__description">抵达终点，悬而未决。</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/snovving"><i class="fab fa-github"></i><span>Come with Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://twitter.com/snovving1" rel="external nofollow noreferrer" target="_blank" title="Twitter"><i class="fab fa-twitter"></i></a><a class="social-icon" href="mailto:snovving@yahoo.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://snovving.top/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">2.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.</span> <span class="toc-text">影响版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">2.3.</span> <span class="toc-text">实验环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0"><span class="toc-number">3.</span> <span class="toc-text">前置学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Apache-%E9%83%A8%E7%BD%B2-php"><span class="toc-number">3.1.</span> <span class="toc-text">Apache 部署 php</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mod-proxy-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">mod_proxy 反向代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Apache-hook-%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">Apache hook 机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1"><span class="toc-number">4.1.</span> <span class="toc-text">代码审计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E9%83%A8%E5%88%86%E6%98%AF%E5%8F%AF%E6%8E%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">4.1.1.</span> <span class="toc-text">哪部分是可控的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDS-%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">UDS 解析过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">漏洞利用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/368b3bb7/" title="CVE-2021-40438 Apache mod_proxy SSRF 漏洞分析">CVE-2021-40438 Apache mod_proxy SSRF 漏洞分析</a><time datetime="2021-11-21T11:30:00.000Z" title="发表于 2021-11-21 19:30:00">2021-11-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/bb793f41/" title="CVE-2021-37580 Apache ShenYu JWT 认证缺陷漏洞分析">CVE-2021-37580 Apache ShenYu JWT 认证缺陷漏洞分析</a><time datetime="2021-11-20T12:40:22.000Z" title="发表于 2021-11-20 20:40:22">2021-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/63c2921e/" title="橙光 V2.31.284.0923 内购任意订单修改漏洞">橙光 V2.31.284.0923 内购任意订单修改漏洞</a><time datetime="2021-11-18T14:30:00.000Z" title="发表于 2021-11-18 22:30:00">2021-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/f5e7bdc4/" title="从 hxp 2020 一道题来看利用 ftp 与 php-fpm 对话 RCE">从 hxp 2020 一道题来看利用 ftp 与 php-fpm 对话 RCE</a><time datetime="2021-10-30T12:20:00.000Z" title="发表于 2021-10-30 20:20:00">2021-10-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/608ab632/" title="CVE-2021-3129 Laravel Debug mode 远程代码执行漏洞分析">CVE-2021-3129 Laravel Debug mode 远程代码执行漏洞分析</a><time datetime="2021-10-30T12:00:00.000Z" title="发表于 2021-10-30 20:00:00">2021-10-30</time></div></div></div></div></div></div></main><footer id="footer" style="background: #88878f"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By snovving</div><div class="footer_custom_text">Winter is coming.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'blog-2ghr66qp8b425638',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'blog-2ghr66qp8b425638',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>